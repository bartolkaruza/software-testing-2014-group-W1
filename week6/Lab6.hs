module Lab6

where
import Data.List
import System.Random
import Test.QuickCheck
import Test.QuickCheck.Monadic
--import Criterion.Main
import Week6

carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) | 
      k <- [2..], 
      isPrime (6*k+1), 
      isPrime (12*k+1), 
      isPrime (18*k+1) ]

{-
	Ex.1 Fast Modular Exponentiation
	See function 'exM' in Week6.hs
-}
	  
{-
	Ex.2 Testing Fast Modular Exponentiation
	
	Using Criterion for benchmarking (cannot run criterion on windows 8, due to mingw 32 linking issues)


main = defaultMain [
		bgroup "exp" [	bench "expM 7 2048 13" $ whnf (expM 7 2048) 13,
						bench "exM 7 2048 13" $ whnf (exM 7 2048) 13
					  ]
		]
	-}	

{- 
	Ex.3 composite number generation
-}

--composites start at |4|
composites = filter (\x -> not $ isPrime x) [4..]

{-
	Ex.4 testing Fermat
-}

-- Increasing k results in a larger chance of finding a correct positive in primeF. So, when we increase k, the size of the 'prime' we find is usually larger than with a lower k.
-- There is always a chance to find the least composite: 4

-- return first encountered composite which is a prime according to primeF
testF :: Int -> IO Integer
testF k = findPrimeF k composites

findPrimeF :: Int -> [Integer] -> IO Integer
findPrimeF k (c:cs) = do 
					  isP <- primeF k c
					  if isP
					  then return c
					  else findPrimeF k cs

-- test first 10000 lookups in the composite list on primeF method and 
-- print those who primeF indicates to be a prime
testComps :: Int -> IO()
testComps k = testList 0 10000 k composites []
						
testList :: Int -> Int -> Int -> [Integer] -> [Integer] -> IO()
testList n max k xs ps = if n == max
					     then print $ reverse ps
					     else do 
							  isP <- primeF k (xs!!n)
							  if isP
							  then testList (n+1) max k xs ((xs!!n):ps)
							  else testList (n+1) max k xs ps		

{- increasing k, results in a lesser chance of finding false positives, for example:  
	
testComps 1
[8,9,21,25,30,39,117,153,169,231,385,481,527,671,1032,1105,1247,1261,1285,1431,1551,1661,1729,1852,1891,2047,2163,2185,2242,2465,2641,2701,2871,2945,3133,3283,3367,4034,4681,4991,5461,6273,6409,6533,6541,6545,6601,7107,7161,7613,7831,8149,8295,8989,9331,9361,9453,9471,10143,10171,10523,10585,10681,11041]

testComps 2
[85,403,703,1105,2465,2821,4033,5551,6601,7363,8695,10585]

testComps 3
[6601,8911,10585]

-}

							  
-- test 10000 random lookups in the composite list on primeF method and 
-- print those who primeF indicates to be a prime
testRndComps :: Int -> Int -> IO()
testRndComps max k = testRndList 10000 max k composites []
							  
testRndList :: Int -> Int -> Int -> [Integer] -> [Integer] -> IO()
testRndList 0 max k xs ps = print $ reverse ps
testRndList n max k xs ps =  do 
							 r <- randomRIO (0, max)
							 isP <- primeF k (xs!!r)
							 if isP
							 then testRndList (n-1) max k xs ((xs!!r):ps)
							 else testRndList (n-1) max k xs ps

{-
	The same applies for randomly picked composites 
	
	*Lab6> testRndComps 10000 1 	[10011,3245,2465,6697,7345,153,1267,1876,6281,1027,248,2896,1921,5713,4123,3605,10735,10585,2465,21,38,152,7449,165,8911,7345,1027,65,361,9191,6925,11305,2465,93,49,6532,11145,671,6601,8911,7865,12,4233,4636,4961,903,9073,1105,95,3277,831,5617,9889,590,65,3059,10309,1729,561,3309,87,483,123,4081]
	*Lab6> testRndComps 10000 2 
	[91,3913,1105,3367,1541,5611,385,481,703,3325,2465,9,9637,2701]
	
	*Lab6> testRndComps 10000 3 
	[65,1729,949,2465,8911,6601]
	
	When we change the lookup range 0-10000 into 0-100000 (by calling testRndComps 100000 k ), even less false positives are found which indicates that larger composites have a lesser chance of being a false positive.
-}
							 
{- QuickCheck.Monadic version: when run on large numbers it gets very slow at around +/- case 30. Need to limit range of idx generated by QuickCheck.
qcFindPrimes :: Int -> Property
qcFindPrimes idx = monadicIO $ do
		isP <- run $ primeF 10 (composites!!(abs idx))
		assert $ not isP
-}
						
{-
	Ex.5 Carmicheal
	
	Fermat's little theorem: 
	b^(p - 1) is equal to b mod p, for any prime p, for all 1 <= b < p
	
	Modular arithmetic congruence: 
	b^n equal to b (mod n) for all 1 < b < n for which b and n are co-prime
	
	These numbers are composites with the same property of modular arithmetic congruence on which Fermat's little theorem is based. Therefore, they should always trigger a false positive when using primeF
-}

testF' :: Int -> IO Integer
testF' k = findPrimeF k carmichael

--always returns the same list of numbers
testCarm :: Int -> IO()
testCarm k = testList 0 100 k carmichael []